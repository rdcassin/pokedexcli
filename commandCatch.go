package main

import (
	"errors"
	"strings"
	"math/rand"
	"time"
	"fmt"
)

func commandCatch(c *config, pokemonIDOrName ...string) error {
	if len(pokemonIDOrName) == 0 {
		return errors.New("please provide a pokemon ID or name")
	}
	
	IDOrName := strings.ToLower(pokemonIDOrName[0])
	
	pokemon, err := c.pokeapiClient.GetPokemonInfo(IDOrName)
	if err != nil {
		return err
	}
	
	/*Logic to determine success/fail of catching.
	1. To succeed in capturing a pokemon, the catchCheck must be greater than or equal to the catchThreshold.
	2. catchCheck = 1 - (baseExperience / (baseExperience + roll)).
	3. "baseExperience" comes from the API call and is specific to each pokemon.
	4. "roll" is generated by the math/rand package and is a number between 0 - 255
	*/
	catchThreshold := 0.28
	baseExperience := float64(pokemon.BaseExperience)
	rollMax := 255
	roll := float64(rand.Intn(rollMax))
	
	catchCheck := float64(1 - (baseExperience / (baseExperience + roll)))
	caught := catchCheck > catchThreshold

	//Setup of the output of the Catching Mechanic
	target := pokemon.Name
	interval := 1 * time.Second
	endTime := time.After(4 * time.Second)

	ticker := time.NewTicker(interval)

	//Printing output of Catching Mechanic
	fmt.Printf("Throwing a Pokeball at %s", target)

	loop:
		for {
			select {
			case <-ticker.C:
				fmt.Print(".")
			case <-endTime:
				ticker.Stop()
				break loop
			}
		}
	
	fmt.Println("")
	if caught {
		fmt.Printf("%s was caught!\n", target)
	} else {
		fmt.Printf("%s escaped!\n", target)
	}

	return nil
}